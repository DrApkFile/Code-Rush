rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // REQUIRED FIRESTORE INDEXES
    // ================================
    // 1. Collection: solo_matches
    //    Fields: player1.uid (Ascending), createdAt (Descending)
    //    Purpose: Used by getUserSoloMatches() to list user's matches in reverse chronological order
    //
    // 2. Collection: game_sessions
    //    Fields: userId (Ascending), startTime (Descending)
    //    Purpose: Used by getUserGameHistory() to list user's sessions in reverse chronological order
    //
    // These indexes should be created via Firebase Console or deployed via firebase deploy --only firestore:indexes
    // See firestore.indexes.json for index configuration.
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    function isValidNewUser() {
      return request.resource.data.keys().hasAll(['uid', 'username', 'email', 'languageRatings', 'createdAt', 'updatedAt']) &&
        request.resource.data.uid == request.auth.uid;
    }

    function isValidRating() {
      return request.resource.data.keys().hasAll(['HTML', 'CSS', 'JavaScript']) &&
        request.resource.data.HTML is number &&
        request.resource.data.CSS is number &&
        request.resource.data.JavaScript is number;
    }

    function isValidChallenge() {
      return request.resource.data.keys().hasAll(['creatorId', 'creatorUsername', 'mode', 'language', 'questionFormat', 'isRated', 'status', 'createdAt']) &&
        request.resource.data.creatorId == request.auth.uid;
    }

    function isValidMatch() {
      let baseFields = ['player1', 'questions', 'mode', 'language', 'status', 'createdAt', 'isRated'];
      let isFriend = request.resource.data.mode == 'friend';
      return request.resource.data.keys().hasAll(baseFields) &&
        (!isFriend || request.resource.data.keys().hasAll(['challengeMode'])) &&
        (request.resource.data.player1.uid == request.auth.uid || 
         (request.resource.data.player2 != null && request.resource.data.player2.uid == request.auth.uid));
    }

      // Allow solo matches (player2 is null/undefined)
      function isValidSoloMatch() {
        return request.resource.data.keys().hasAll(['player1', 'language', 'mode', 'status', 'createdAt']) &&
          request.resource.data.player1.uid == request.auth.uid &&
          (request.resource.data.player2 == null || !("player2" in request.resource.data));
      }

      // Validate a new game session. 'format' is optional and startTime may be a serverTimestamp.
    function isValidGameSession() {
      let requiredFields = ['userId', 'mode', 'language', 'status'];
      let validMode = request.resource.data.mode in ['3min', '5min', 'survival'];
      let validLanguage = request.resource.data.language in ['HTML', 'CSS', 'JavaScript'];
      let validStatus = request.resource.data.status in ['in_progress', 'completed', 'abandoned'];

      return request.resource.data.keys().hasAll(requiredFields) &&
        validMode &&
        validLanguage &&
        validStatus &&
        request.auth != null && request.resource.data.userId == request.auth.uid;
    }

    // Users collection
    match /users/{userId} {
      // Allow reading individual user profiles and searching
      allow get, list: if true;  // Allow all reads for login and search
      
      // Allow creating new user profile during signup
      allow create: if request.resource.data.keys().hasAll(['uid', 'username', 'email', 'languageRatings', 'createdAt', 'updatedAt']) &&
                   request.resource.data.uid == request.auth.uid;
      
      // Allow updating own profile
      allow update: if isAuthenticated() && 
                   isOwner(userId) &&
                   request.resource.data.diff(resource.data).affectedKeys()
                     .hasAny(['bio', 'profilePicture', 'languageRatings', 'updatedAt']);
      
      // Allow deleting own profile
      allow delete: if isAuthenticated() && isOwner(userId);
    }

    // Friends collection
    match /friends/{friendId} {
      // Allow reading accepted friendships to any authenticated user so public
      // friend lists and counts can be shown, while keeping pending/other
      // docs visible only to the involved parties.
      allow get: if isAuthenticated() &&
        (resource.data.userId == request.auth.uid || resource.data.friendId == request.auth.uid || resource.data.status == 'accepted');

      // list queries may return multiple documents; allow listing only when
      // the documents are accepted friendships or involve the requesting user.
      allow list: if isAuthenticated() &&
        (resource.data.status == 'accepted' || resource.data.userId == request.auth.uid || resource.data.friendId == request.auth.uid);

      allow create: if isAuthenticated() && 
        (request.resource.data.userId == request.auth.uid || 
         request.resource.data.friendId == request.auth.uid) &&
        request.resource.data.keys().hasAll(['userId', 'friendId', 'status', 'createdAt']);

      allow update: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         resource.data.friendId == request.auth.uid) &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['status', 'acceptedAt']);

      allow delete: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         resource.data.friendId == request.auth.uid);
    }

    // Game sessions collection
    match /game_sessions/{sessionId} {
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid);
      // Allow listing sessions only when filtered by the requesting userId
      allow list: if isAuthenticated() && request.query.userId == request.auth.uid;
      // Allow create when the requester is authenticated and the declared userId
      // matches the authenticated uid. Validate mode/language/status values but
      // avoid strict key-list checks which can reject documents with additional
      // helper fields (timestamps/serverTimestamps, arrays, etc.). This is a
      // pragmatic allowance to reduce 'insufficient permissions' failures from
      // client-side game session creation while still guarding identity and
      // core field values.
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.mode in ['3min', '5min', 'survival'] &&
        request.resource.data.language in ['HTML', 'CSS', 'JavaScript'] &&
        request.resource.data.status in ['in_progress', 'completed', 'abandoned'];

      // Allow the session owner to update their in-progress sessions. This
      // permits client-side updateDoc calls that change any session field
      // while the session is still active (e.g. progress, answers, timeLeft).
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid &&
        resource.data.status != 'completed';

      // After a session is completed, only allow the owner to write a very
      // small, explicit set of post-completion metadata fields (for example
      // attaching a ratingChange or savedMatchId). This prevents arbitrary
      // edits to finished sessions while allowing necessary client-side
      // follow-ups.
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid &&
        resource.data.status == 'completed' &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['ratingChange', 'savedMatchId', 'updatedAt', 'reviewed']);

      allow delete: if false;
    }



    // Matches collection - for both friend and random matchmaking
    match /matches/{matchId} {
      // Allow anybody to read a match document by ID to support unauthenticated spectators
      allow get: if true;
      
      // Allow list for own matches
      allow list: if isAuthenticated() && (
        resource.data.player1.uid == request.auth.uid ||
        (resource.data.player2 != null && resource.data.player2.uid == request.auth.uid)
      );

      // Allow creating matches (multiplayer or solo)
      allow create: if isAuthenticated() && (isValidMatch() || isValidSoloMatch());

      allow update: if isAuthenticated() && (
        resource.data.player1.uid == request.auth.uid ||
        (resource.data.player2 != null && resource.data.player2.uid == request.auth.uid)
      ) &&
      request.resource.data.diff(resource.data).affectedKeys()
        .hasAny(['player1', 'player2', 'status', 'endedAt', 'winner', 'questions', 'rematch']);
    }

    // Solo matches collection - canonical final match records for solo games
    // These are immutable once created, containing full question data, answers, and rating snapshots
    match /solo_matches/{matchId} {
      // Allow reading any completed solo match (public history view)
      allow read: if resource.data.status == 'completed' || (isAuthenticated() && resource.data.player1.uid == request.auth.uid);
      
      // Allow creating a new solo match record at game end
      // Must have: player1 with uid/username/languageRatings snapshot, language, mode, status, questions, answers,
      // ratingBefore, ratingAfter, ratingChange, timestamps
      allow create: if isAuthenticated() && 
        request.resource.data.keys().hasAll(['player1', 'language', 'mode', 'status', 'createdAt', 'questions', 'answers', 'ratingBefore', 'ratingAfter', 'ratingChange']) &&
        request.resource.data.player1.uid == request.auth.uid &&
        request.resource.data.language in ['HTML', 'CSS', 'JavaScript'] &&
        request.resource.data.mode in ['solo', '3min', '5min', 'survival'] &&
        request.resource.data.status == 'completed';
      
      // Solo matches are immutable once created (no updates allowed)
      allow update: if false;
      allow delete: if false;
    }

    // Questions collection
    match /questions/{questionId} {
      allow read: if true;
      // Clients may read questions. Creation/update/delete should be done via
      // the Admin SDK (seeding) to avoid exposing write access to clients.
      allow create: if false;
      allow update, delete: if false;
    }

    // Waiting pool collection - used for random matchmaking
    match /waiting_pool/{poolId} {
      allow get: if isAuthenticated();
      // Allow list for finding potential opponents (queried by language)
      allow list: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'username', 'languageRatings', 'language', 'joinedAt']);
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }

    // Ratings history collection
    match /ratings/{ratingId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'language', 'oldRating', 'newRating', 'timestamp']) &&
        request.resource.data.timestamp <= request.time;
      allow update, delete: if false;
    }

    // User status collection (for online/offline status)
    match /user-status/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isOwner(userId);
      allow update: if isAuthenticated() && isOwner(userId);
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Allow users to read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Allow clients to create notifications
      allow create: if isAuthenticated() && 
        request.resource.data.keys().hasAll(['userId', 'type', 'fromUserId', 'read', 'createdAt']) &&
        request.resource.data.type in ['friend_request_received', 'friend_request_accepted', 'friend_request_rejected', 'challenge_received', 'challenge_accepted', 'challenge_declined'];
      
      // Allow users to update read status of their own notifications.
      allow update: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || request.resource.data.userId == request.auth.uid) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      
      // Allow users to delete their own notifications
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Challenges collection - updated for friend challenges
    match /challenges/{challengeId} {
      // Allow anyone to read challenge info (creator, mode, etc) to show joining page
      allow get: if true;
      
      // Allow list for own challenges only
      allow list: if isAuthenticated() && request.query.creatorId == request.auth.uid;
      
      // Allow creating challenges
      allow create: if isAuthenticated() && 
        request.resource.data.creatorId == request.auth.uid &&
        request.resource.data.keys().hasAll(['creatorId', 'creatorUsername', 'mode', 'language', 'questionFormat', 'isRated', 'status', 'createdAt']);
      
      // Allow updating status (accept/decline) and linking match/notification
      allow update: if isAuthenticated() && 
        (resource.data.creatorId == request.auth.uid || resource.data.opponentId == request.auth.uid || resource.data.opponentId == "") &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasAny(['status', 'acceptedAt', 'declinedAt', 'matchId', 'opponentId', 'opponentUsername', 'opponentElo', 'opponentProfilePic', 'notificationId']);
    }
  }
}